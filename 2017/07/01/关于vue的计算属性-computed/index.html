<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>关于vue的计算属性(computed) | Shengjie Lu</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">关于vue的计算属性(computed)</h1><a id="logo" href="/.">Shengjie Lu</a><p class="description">Stay Hungry,Stay foolish</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">关于vue的计算属性(computed)</h1><div class="post-meta">Jul 1, 2017<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a data-disqus-identifier="2017/07/01/关于vue的计算属性-computed/" href="/2017/07/01/关于vue的计算属性-computed/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>最近一段时间在看<code>Vue.js@2.0</code>，突然对它的计算属性比较感兴趣，想知道它的依赖收集的实现方式，所以看了下源码。<br>先总结大致原理：<code>computed properties</code>的依赖收集是一种懒执行过程，在实例初始化的时候，程序会先执行一遍各自的<code>computor</code>(对应的<code>function</code>)。这个过程中，被依赖的响应式属性（被依赖者）的<code>getter</code>被触发，<code>getter</code>中会将<strong>计算属性</strong>（依赖者）的<code>watcher</code>加入到一个集合里。所以，在以后的过程中，一旦被依赖者发生改变，将会触发所有依赖者的<code>watcher</code>，从而更新对应的<code>property</code>，<strong>下面说说自己寻找真相的轨迹：</strong></p>
<p>飞速得跳跃式得浏览了下源码，首先找到了这个<code>initComputed</code>函数，很容易看出应该是计算属性初始化的部分(部分代码用省略号代替)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span> (<span class="params">vm, computed</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> watchers = vm._computedWatchers = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> computed) &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// create internal watcher for the computed property.</span></div><div class="line">    watchers[key] = <span class="keyword">new</span> Watcher(vm, getter, noop, computedWatcherOptions);</div><div class="line"></div><div class="line">    <span class="comment">// component-defined computed properties are already defined on the</span></div><div class="line">    <span class="comment">// component prototype. We only need to define computed properties defined</span></div><div class="line">    <span class="comment">// at instantiation here.</span></div><div class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</div><div class="line">      defineComputed(vm, key, userDef);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> vm.$data) &#123;</div><div class="line">        warn((<span class="string">"The computed property \""</span> + key + <span class="string">"\" is already defined in data."</span>), vm);</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.$options.props &amp;&amp; key <span class="keyword">in</span> vm.$options.props) &#123;</div><div class="line">        warn((<span class="string">"The computed property \""</span> + key + <span class="string">"\" is already defined as a prop."</span>), vm);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码乍一看，没有什么内容。那么按照惯例重点看注释，明显有两段内容比较重要（有注释的两段），第一部分为每个<code>key</code>创建内部<code>watcher</code>，先观察这部分，找到<code>Class Watcher</code>的源码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Evaluate the getter, and re-collect dependencies.</div><div class="line"> */</div><div class="line">Watcher.prototype.get = <span class="function"><span class="keyword">function</span> <span class="title">get</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  pushTarget(<span class="keyword">this</span>);</div><div class="line">  <span class="keyword">var</span> value;</div><div class="line">  <span class="keyword">var</span> vm = <span class="keyword">this</span>.vm;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      value = <span class="keyword">this</span>.getter.call(vm, vm);</div><div class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">      handleError(e, vm, (<span class="string">"getter for watcher \""</span> + (<span class="keyword">this</span>.expression) + <span class="string">"\""</span>));</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    value = <span class="keyword">this</span>.getter.call(vm, vm);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// "touch" every property so they are all tracked as</span></div><div class="line">  <span class="comment">// dependencies for deep watching</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</div><div class="line">    traverse(value);</div><div class="line">  &#125;</div><div class="line">  popTarget();</div><div class="line">  <span class="keyword">this</span>.cleanupDeps();</div><div class="line">  <span class="keyword">return</span> value</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个<code>get</code>方法会在<code>Watcher</code>的构造函数中被调用，从注释可以看出可能是在这里进行依赖收集。这段代码中有这么一段注释<em>“touch” every property so they are all tracked as dependencies for deep watching</em>，可以理解为在这注释上面的代码中调用<code>this.getter</code>这个方法的时候访问每个属性(响应式属性)，使得它们作为依赖被追踪到。</p>
<p>这时候可以猜到是<code>Vue</code>在这些响应式属性的<code>getter</code>里做了什么手脚，直接来到定义响应式属性的部分</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Define a reactive property on an Object.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive$$1</span> (<span class="params"></span></span></div><div class="line">  obj,</div><div class="line">  key,</div><div class="line">  val,</div><div class="line">  customSetter</div><div class="line">) &#123;</div><div class="line">  <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep();</div><div class="line"></div><div class="line">  <span class="keyword">var</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key);</div><div class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// cater for pre-defined getter/setters</span></div><div class="line">  <span class="keyword">var</span> getter = property &amp;&amp; property.get;</div><div class="line">  <span class="keyword">var</span> setter = property &amp;&amp; property.set;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> childOb = observe(val);</div><div class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</div><div class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> value = getter ? getter.call(obj) : val;</div><div class="line">      <span class="keyword">if</span> (Dep.target) &#123;</div><div class="line">        dep.depend();</div><div class="line">        <span class="keyword">if</span> (childOb) &#123;</div><div class="line">          childOb.dep.depend();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</div><div class="line">          dependArray(value);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> value</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> value = getter ? getter.call(obj) : val;</div><div class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></div><div class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">      &#125;</div><div class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></div><div class="line">      <span class="keyword">if</span> (<span class="string">"development"</span> !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</div><div class="line">        customSetter();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (setter) &#123;</div><div class="line">        setter.call(obj, newVal);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        val = newVal;</div><div class="line">      &#125;</div><div class="line">      childOb = observe(newVal);</div><div class="line">      dep.notify();</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要看<code>set</code>的部分，当定义<strong>计算属性</strong>的时候<code>Dep.target</code>是对应属性的<code>watcher</code>，这点可以由上面提到过的<code>Watcher get</code>这个方法中<code>pushTarget(this)</code>可以得出，具体可以看<code>pushTarget</code>这个方法（略过）。然后看到关键部分<code>dep.depend()</code>这句。每个响应式属性的<code>getter</code>的上下文都会有一个对应的<code>dep</code>对象，顾名思义是依赖的意思。然后<code>depend</code>方法实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Dep.prototype.depend = <span class="function"><span class="keyword">function</span> <span class="title">depend</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (Dep.target) &#123;</div><div class="line">    Dep.target.addDep(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到它又调用了<code>watcher</code>的<code>addDep</code>方法，这个方法具体内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Add a dependency to this directive.</div><div class="line"> */</div><div class="line">Watcher.prototype.addDep = <span class="function"><span class="keyword">function</span> <span class="title">addDep</span> (<span class="params">dep</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> id = dep.id;</div><div class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</div><div class="line">    <span class="keyword">this</span>.newDepIds.add(id);</div><div class="line">    <span class="keyword">this</span>.newDeps.push(dep);</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</div><div class="line">      dep.addSub(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>过程简单叙述为<strong>计算属性</strong>有一个<code>Set</code>(对应的<code>newDepIds</code>和<code>depIds</code>都是，<code>Set</code>是一个<code>polyfill</code>)集合，当<code>dep</code>(与被依赖者对应)不存在于这个集合中时，会将<code>dep</code>添加到这里边去，并且会调用<code>dep</code>的<code>addSub</code>方法， 将依赖者的<code>watcher</code>存放于这个<code>dep</code>的<code>subs</code>属性中。<br>到这里结论就显而易见了， 这样的目的肯定是为了被依赖者每次改变也就是调用<code>setter</code>的时候，会触发所有对应的依赖者的<code>watcher</code>，并更新对应的依赖者的属性。事实上也正是如此，响应式属性的<code>setter</code>会调用<code>dep.notify()</code>而这个方法也正是触发<code>dep.subs</code>下的所有依赖者的<code>watcher</code>的<code>update</code>方法。<br>更进一步的是，每次<code>watcher</code>更新会重新收集依赖。这个过程会将<code>newDepIds</code>和<code>depIds</code>比较，存在于<code>depIds</code>而不存在于<code>newDepIds</code>中的<code>dep</code>，就是新一轮依赖收集后不再依赖的被依赖者，此时程序会将二者的关联断开，即清理被依赖者。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://jackclown.github.io/2017/07/01/关于vue的计算属性-computed/" data-id="cjff9t1nd0000p0uc9vmdzh2u" class="article-share-link">分享</a><div class="tags"><a href="/tags/Vue/">Vue</a></div><div class="post-nav"><a href="/2017/08/20/实现DOM-Resize-Listener/" class="pre">实现DOM Resize Listener思路</a><a href="/2017/06/25/关于一个v8内存泄漏的案例/" class="next">关于一个v8内存泄漏的案例</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'shengjielu';
var disqus_identifier = '2017/07/01/关于vue的计算属性-computed/';
var disqus_title = '关于vue的计算属性(computed)';
var disqus_url = 'https://jackclown.github.io/2017/07/01/关于vue的计算属性-computed/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/favicon.ico',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//shengjielu.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://jackclown.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Vue/" style="font-size: 15px;">Vue</a> <a href="/tags/v8/" style="font-size: 15px;">v8</a> <a href="/tags/Javascsript/" style="font-size: 15px;">Javascsript</a> <a href="/tags/个人总结/" style="font-size: 15px;">个人总结</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/03/31/迟到的2017年总结/">迟到的2017年总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/20/实现DOM-Resize-Listener/">实现DOM Resize Listener思路</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/01/关于vue的计算属性-computed/">关于vue的计算属性(computed)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/25/关于一个v8内存泄漏的案例/">关于一个v8内存泄漏的案例</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//shengjielu.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Shengjie Lu.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>